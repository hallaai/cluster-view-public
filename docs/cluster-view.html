<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Medoids Clustering for Map Points</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .slide {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            margin: 20px 0;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none; /* Hide all slides by default */
        }

        h1 {
            color: #2c3e50;
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: #34495e;
            font-size: 1.8em;
            margin-bottom: 20px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        h3 {
            color: #2980b9;
            font-size: 1.4em;
            margin: 20px 0 15px 0;
        }
        
        h4 {
            color: #1a5276;
            font-size: 1.2em;
            margin: 15px 0 10px 0;
        }

        .diagram-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 30px 0;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .diagram-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            min-width: 150px;
        }

        .diagram-arrow {
            font-size: 2em;
            color: #3498db;
            margin: 0 10px;
            align-self: center;
        }
        
        .code-block {
            background-color: #2d3748; /* Darker background for code */
            color: #e2e8f0; /* Light text color */
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            overflow-x: auto;
            margin: 15px 0;
            border: 1px solid #4a5568;
        }

        .map-visual {
            width: 300px;
            height: 200px;
            background: linear-gradient(45deg, #e8f5e8, #f0f8ff);
            border: 2px solid #3498db;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
        }

        .point {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            position: absolute;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .point:hover {
            transform: scale(1.3);
        }

        .cluster-1 { background: #e74c3c; }
        .cluster-2 { background: #3498db; }
        .cluster-3 { background: #2ecc71; }
        .cluster-4 { background: #f39c12; }
        .cluster-5 { background: #9b59b6; }

        .medoid {
            width: 16px;
            height: 16px;
            border: 3px solid #2c3e50;
            box-shadow: 0 0 0 3px rgba(44, 62, 80, 0.3);
        }

        .algorithm-flow {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .algorithm-flow-wide {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); /* Wider for more text */
            gap: 20px;
            margin: 30px 0;
        }

        .flow-step {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            position: relative;
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: center; /* Vertically center content */
            align-items: center; /* Horizontally center content */
            min-height: 120px; /* Ensure consistent height */
        }

        .flow-step:hover {
            transform: translateY(-5px);
        }

        .flow-step::after {
            content: '‚Üí';
            position: absolute;
            right: -30px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 24px;
            color: #2c3e50;
        }

        .flow-step:last-child::after {
            display: none;
        }
        
        .flow-step.no-arrow::after {
            display:none;
        }

        .matrix-visual {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 2px;
            width: 200px;
            height: 200px;
            margin: 20px auto;
        }

        .matrix-cell {
            background: linear-gradient(45deg, #ddd, #fff);
            border: 1px solid #bbb;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: #666;
            transition: all 0.3s ease;
        }

        .matrix-cell:hover {
            background: #3498db;
            color: white;
            transform: scale(1.1);
        }

        .metrics-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .metric-card {
            background: linear-gradient(135deg, #00b894, #00a085);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }

        .controls-visual {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border-left: 5px solid #3498db;
        }

        .control-item {
            display: flex;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .control-icon {
            width: 30px;
            height: 30px;
            background: #3498db;
            border-radius: 50%;
            margin-right: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .silhouette-visual {
            width: 100%;
            height: 100px;
            background: linear-gradient(to right, #e74c3c 0%, #f39c12 50%, #2ecc71 100%);
            border-radius: 10px;
            position: relative;
            margin: 20px 0;
        }

        .silhouette-marker {
            position: absolute;
            top: -10px;
            width: 20px;
            height: 20px;
            background: #2c3e50;
            border-radius: 50%;
            transform: translateX(-50%);
        }
        
        .silhouette-diagram {
            display: flex;
            justify-content: space-around;
            align-items: flex-start;
            gap: 20px;
            margin: 20px 0;
        }
        .silhouette-item {
            text-align: center;
            max-width: 300px;
        }
        .silhouette-viz-box {
            width: 200px;
            height: 120px;
            background-color: #ecf0f1;
            border: 1px solid #bdc3c7;
            border-radius: 8px;
            position: relative;
            margin: 0 auto;
        }
        .point-p {
            border: 2px solid #2c3e50 !important;
            box-shadow: 0 0 0 3px rgba(44, 62, 80, 0.3) !important;
            z-index: 10;
            font-size: 9px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #2c3e50;
            transform: scale(1.3);
        }

        .result-section {
            background: linear-gradient(135deg, #fd79a8, #e84393);
            color: white;
            padding: 30px;
            border-radius: 20px;
            margin: 30px 0;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 5px rgba(0,0,0,0.5); }
            50% { transform: scale(1.1); box-shadow: 0 0 15px rgba(255, 221, 87, 0.8); }
        }

        .animated-point {
            animation: pulse 2s infinite;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid white;
        }
        
        .k-medoids-visual {
            width: 350px;
            height: 250px;
            position: relative;
            background: linear-gradient(45deg, #e8f5e8, #f0f8ff);
            border: 2px solid #3498db;
            border-radius: 15px;
        }
        .k-medoids-visual .point {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        .k-medoids-visual .medoid {
            width: 14px;
            height: 14px;
            border: 2px solid #000;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            z-index: 10;
        }
        .k-medoids-visual .new-medoid {
            animation: pulse 1.5s infinite;
            border-color: #ffdd57; /* yellow */
        }
        .k-medoids-visual svg {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        .k-medoids-visual .point {
            z-index: 5;
        }
        .k-medoids-visual svg line {
            stroke-width: 1.5px;
            opacity: 0.4;
        }

        .slide.active {
            display: block; /* Show only the active slide */
        }

        .navigation-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 20px;
            background: rgba(44, 62, 80, 0.8);
            padding: 10px 20px;
            border-radius: 50px;
            color: white;
            z-index: 1000;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .nav-button {
            background: none;
            border: none;
            color: white;
            font-size: 2em;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .nav-button:hover {
            transform: scale(1.2);
        }

        #slide-counter {
            font-size: 1.2em;
            font-weight: bold;
            min-width: 80px; /* To prevent layout shift */
            text-align: center;
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .algorithm-overview {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }

        .algorithm-overview h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.4rem;
        }

        .algorithm-overview p {
            color: #555;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .key-features {
            background: linear-gradient(135deg, #fff5f5, #fed7d7);
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid #e53e3e;
        }

        .key-features h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.4rem;
        }

        .feature-list {
            list-style: none;
        }

        .feature-list li {
            color: #555;
            margin-bottom: 10px;
            padding-left: 25px;
            position: relative;
        }

        .feature-list li::before {
            content: "‚úì";
            position: absolute;
            left: 0;
            color: #e53e3e;
            font-weight: bold;
            font-size: 1.2rem;
        }

    </style>
</head>
<body>
    <div class="container">
        <!-- Title Slide -->
        <div class="slide">
            <h1>üó∫Ô∏è K-Medoids Clustering for Map Points</h1>
            <div class="diagram-container">
                <div class="map-visual" id="titleMap">
                    <!-- Points will be added by JavaScript -->
                </div>
            </div>
            <p style="text-align: center; font-size: 1.2em; color: #666; margin-top: 20px;">
                Intelligent clustering of geographic points using time-travel distance matrices
            </p>
            <img 
            src="data:image/png;base64,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" 
            alt="Dynamik made"
            style="position: fixed; top: 2rem; left: 2rem; width: 54px; height: 54px; pointer-events: none; z-index: 1001;"
            />
        </div>

        <!-- Overview Slide -->
        <div class="slide">
            <h2>üìä Application Overview</h2>
            <p style="font-size: 1.1em; line-height: 1.6; margin-bottom: 20px;">
                This application clusters geographic points on a map using the K-Medoids algorithm and a time-travel distance matrix. 
                Instead of using simple Euclidean distances, it considers real-world travel times between locations.
            </p>
            
            <div class="controls-visual">
                <h3>User Controls</h3>
                <div class="control-item">
                    <div class="control-icon">üìê</div>
                    <div>
                        <strong>Distance Matrix:</strong> JSON matrix defining travel times between all point pairs
                    </div>
                </div>
                 <div class="control-item">
                    <div class="control-icon">üìç</div>
                    <div>
                        <strong>Locations File (Optional):</strong> JSON file with point names and lat/lon coordinates for map display
                    </div>
                </div>
                <div class="control-item">
                    <div class="control-icon">üî¢</div>
                    <div>
                        <strong>Cluster Range (k):</strong> Minimum and maximum number of clusters to explore
                    </div>
                </div>
                <div class="control-item">
                    <div class="control-icon">üë•</div>
                    <div>
                        <strong>Min Cluster Size:</strong> Minimum points required for a valid cluster
                    </div>
                </div>
            </div>
        </div>

        <!-- Distance Matrix Slide -->
        <div class="slide">
            <h2>üìê Time-Travel Distance Matrix</h2>
            <p style="margin-bottom: 20px;">
                The distance matrix contains travel times (e.g., in minutes) between every pair of points.
            </p>
            
            <div class="diagram-container">
                <div class="matrix-visual" id="distanceMatrix">
                    <!-- Matrix cells will be populated by JavaScript -->
                </div>
                <div style="margin-left: 30px;">
                    <h3>Matrix Properties:</h3>
                    <ul style="line-height: 1.8;">
                        <li>‚úÖ Symmetric: distance(A,B) = distance(B,A)</li>
                        <li>‚úÖ Diagonal zeros: distance(A,A) = 0</li>
                        <li>üöó Real travel times, not straight-line distances</li>
                        <li>üìç Accounts for roads, traffic, terrain</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <!-- Algorithm Deep Dive Intro -->
        <div class="slide">
            <h2>üß† Algorithm Deep Dive</h2>
        <!--    <p style="font-size: 1.1em; line-height: 1.6; margin-bottom: 20px;">
                The application employs a simulated K-Medoids algorithm to group points. It iterates through a user-defined range of cluster counts (k) and selects the 'k' that yields the best clustering quality based on minimizing total intra-cluster distances, while also considering silhouette scores for insight. Let's explore the key functions involved.
            </p>
        -->
        <div class="content-grid">
            <div class="algorithm-overview">
                <h3>üîç Algorithm Overview</h3>
                <p>The application employs a simulated K-Medoids algorithm to group points. It iterates through a user-defined range of cluster counts (k) and selects the 'k' that yields the best clustering quality based on minimizing total intra-cluster distances, while also considering silhouette scores for insight. Let's explore the key functions involved.</p>
                <p>Unlike K-Means, K-Medoids uses actual data points as cluster centers (medoids), making it more robust to outliers and suitable for non-Euclidean distance metrics.</p>
            </div>

            <div class="key-features">
                <h3>‚ö° Key Features</h3>
                <ul class="feature-list">
                    <li>Automatic optimal K selection</li>
                    <li>Minimizes intra-cluster distances</li>
                    <li>Silhouette score validation</li>
                    <li>Robust to outliers</li>
                    <li>User-defined K range testing</li>
                </ul>
            </div>
        </div>

        </div>

        <!-- runClusteringAlgorithm Slide -->
        <div class="slide">
            <h2>‚öôÔ∏è Main Orchestrator: `runClusteringAlgorithm`</h2>
            <p>This function manages the entire clustering workflow from input processing to result generation.</p>
            <div class="algorithm-flow-wide">
                <div class="flow-step">
                    <h4>1. Input</h4>
                    <p>Receives distance matrix string & parameters (min/max k, min size).</p>
                </div>
                <div class="flow-step">
                    <h4>2. Parse & Validate</h4>
                    <p>Validates matrix structure (`DistanceMatrixSchema`) & parameters (`validateBaseParams`, `validateNodeCounts`).</p>
                </div>
                <div class="flow-step">
                    <h4>3. Prepare Data</h4>
                    <p>Identifies unique nodes. Calls `buildDistanceMap` for efficient distance lookups.</p>
                </div>
                <div class="flow-step">
                    <h4>4. Iterate K Values</h4>
                    <p>Loops from min_k to max_k. For each k: calls `runKMedoidsSimulation` & `calculateSilhouetteScore`.</p>
                </div>
                <div class="flow-step">
                    <h4>5. Select Best K</h4>
                    <p>Chooses k with lowest total intra-cluster distance among valid solutions. Stores all metrics.</p>
                </div>
                <div class="flow-step no-arrow">
                    <h4>6. Output</h4>
                    <p>Returns chosen clusters, chosen k, all metrics, and any warnings.</p>
                </div>
            </div>
        </div>

        <!-- Data Prep & Validation Slide -->
        <div class="slide">
            <h2>üõ†Ô∏è Data Preparation & Validation</h2>
            <h4>`validateBaseParams` & `validateNodeCounts`</h4>
            <p>Before any clustering, parameters (min/max clusters, min size) and data characteristics (e.g., enough unique nodes) are checked for logical consistency. This prevents unnecessary computations with invalid inputs.</p>
            
            <h4>`buildDistanceMap(matrix, nodes)`</h4>
            <p>Converts the input array of distance entries into a nested Map for efficient lookups. This allows quick retrieval of the distance between any two points.</p>
            <div class="diagram-container">
                <div class="diagram-item">
                    <p><strong>Input Distance Matrix (Array)</strong></p>
                    <div class="code-block" style="font-size: 0.8em; padding: 10px; max-width: 250px;">
                        [{from:1,to:2,dist:10},<br>
                         {from:1,to:3,dist:5},<br>
                         {from:2,to:3,dist:8}]
                    </div>
                </div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-item">
                    <p><strong>Output `distanceMap` (Nested Map)</strong></p>
                    <div class="code-block" style="font-size: 0.8em; padding: 10px; max-width: 300px;">
                        Map {<br>
                        &nbsp;&nbsp;1 => Map { 2=>10, 3=>5 },<br>
                        &nbsp;&nbsp;2 => Map { 1=>10, 3=>8 },<br>
                        &nbsp;&nbsp;3 => Map { 1=>5, 2=>8 }<br>
                        }
                    </div>
                </div>
            </div>
            <p>The `getDistance(node1, node2, distanceMap)` function then uses this map to return distances.</p>
        </div>

        <!-- K-Medoids Simulation Part 1 -->
        <div class="slide">
            <h2>üîÑ K-Medoids Simulation: `runKMedoidsSimulation` (Part 1)</h2>
            <p>This function attempts to find the best `targetK` medoids (cluster centers) and assign points to them. It's an iterative process.</p>
            
            <h4>1. Initialization</h4>
            <p>Select `targetK` unique data points randomly from all available nodes to serve as the initial medoids (cluster centers).</p>
            <div class="diagram-container">
                 <div class="map-visual k-medoids-visual" id="kmedoids-init"></div>
            </div>

            <h4>2. Assignment Step (Iterative)</h4>
            <p>For each data point, calculate its distance (using `getDistance`) to every current medoid. Assign the point to the cluster represented by the closest medoid.</p>
            <div class="diagram-container">
                <div class="map-visual k-medoids-visual" id="kmedoids-assign"></div>
            </div>
            <p>This forms an initial set of clusters based on the current medoids.</p>
        </div>

        <!-- K-Medoids Simulation Part 2 -->
        <div class="slide">
            <h2>üîÑ K-Medoids Simulation: `runKMedoidsSimulation` (Part 2)</h2>
            <h4>3. Update Step (Iterative)</h4>
            <p>For each cluster formed in the assignment step:</p>
            <ul style="list-style-type: disc; margin-left: 20px; line-height: 1.6;">
                <li>Iterate through every point within that cluster.</li>
                <li>Consider each point as a *potential new medoid* for that cluster.</li>
                <li>Calculate the sum of distances from this potential new medoid to all *other* points within the same cluster.</li>
                <li>The point that minimizes this sum becomes the new medoid for that cluster.</li>
            </ul>
            <p>This step aims to find a more central point within each cluster to serve as its medoid, reducing the total intra-cluster distance.</p>
             <div class="diagram-container">
                <div class="map-visual k-medoids-visual" id="kmedoids-update"></div>
            </div>

            <h4>4. Convergence & Repetition</h4>
            <p>The Assignment and Update steps are repeated for a fixed number of iterations (e.g., 10) or until the set of medoids no longer changes between iterations (convergence).</p>
            
            <h4>5. Final Clusters & Validation</h4>
            <p>After iterations, final clusters are formed. Only clusters meeting the `minClusterSize` are considered valid. The total sum of distances from medoids to their cluster members (Total Intra-Cluster Distance) for this `targetK` is calculated.</p>
        </div>
        
        <!-- Silhouette Score Slide -->
        <div class="slide">
            <h2>‚öñÔ∏è Evaluating Cluster Quality: `calculateSilhouetteScore`</h2>
            <p>The Silhouette Score measures how similar a point is to its own cluster compared to other clusters. It provides insight into the "goodness" of fit for each point. Scores range from -1 to +1.</p>
            
            <div class="silhouette-diagram" style="align-items: stretch;">
                <div class="silhouette-item" style="flex: 1;">
                    <h4>a(P) - Mean Intra-Cluster Distance</h4>
                    <p>The average distance from a point `P` to all other points in its <strong>own cluster</strong>.<br><em>A small `a(P)` value means P is well-matched to its cluster.</em></p>
                </div>
                <div class="silhouette-item" style="flex: 1;">
                    <h4>b(P) - Mean Nearest-Cluster Distance</h4>
                    <p>The average distance from `P` to all points in the <strong>next nearest cluster</strong>.<br><em>A large `b(P)` value means P is well-separated from other clusters.</em></p>
                </div>
            </div>

            <h4 style="text-align:center; margin-top:20px;">Silhouette Score for Point P: S(P) = (b(P) - a(P)) / max(a(P), b(P))</h4>
            
            <div class="diagram-container" style="align-items: flex-start; margin-top: 30px; gap: 30px;">
                <!-- Case 1: Score ‚âà +1 -->
                <div class="diagram-item" style="min-width: 220px;">
                    <h4 style="margin-bottom: 10px;">Score ‚âà +1 (Well-Clustered)</h4>
                    <div class="silhouette-viz-box">
                        <!-- Points for Cluster A -->
                        <div class="point cluster-1" style="top: 40%; left: 20%;"></div>
                        <div class="point cluster-1" style="top: 60%; left: 30%;"></div>
                        <!-- Point P -->
                        <div class="point cluster-1 point-p" style="top: 50%; left: 25%;">P</div>
                        <!-- Points for Cluster B -->
                        <div class="point cluster-2" style="top: 30%; left: 75%;"></div>
                        <div class="point cluster-2" style="top: 50%; left: 85%;"></div>
                        <div class="point cluster-2" style="top: 70%; left: 80%;"></div>
                    </div>
                    <p style="font-size: 0.9em; margin-top: 10px;">Point P is close to its own cluster (small `a(P)`) and far from the neighbor (large `b(P)`).</p>
                </div>
                <!-- Case 2: Score ‚âà 0 -->
                <div class="diagram-item" style="min-width: 220px;">
                    <h4 style="margin-bottom: 10px;">Score ‚âà 0 (On Boundary)</h4>
                    <div class="silhouette-viz-box">
                        <!-- Points for Cluster A -->
                        <div class="point cluster-1" style="top: 40%; left: 20%;"></div>
                        <div class="point cluster-1" style="top: 60%; left: 30%;"></div>
                        <!-- Point P -->
                        <div class="point cluster-1 point-p" style="top: 50%; left: 45%;">P</div>
                        <!-- Points for Cluster B -->
                        <div class="point cluster-2" style="top: 40%; left: 65%;"></div>
                        <div class="point cluster-2" style="top: 60%; left: 75%;"></div>
                    </div>
                    <p style="font-size: 0.9em; margin-top: 10px;">Point P is roughly equidistant from both clusters (`a(P)` ‚âà `b(P)`).</p>
                </div>
                <!-- Case 3: Score ‚âà -1 -->
                <div class="diagram-item" style="min-width: 220px;">
                    <h4 style="margin-bottom: 10px;">Score ‚âà -1 (Misclassified)</h4>
                    <div class="silhouette-viz-box">
                        <!-- Points for Cluster A -->
                        <div class="point cluster-1" style="top: 40%; left: 20%;"></div>
                        <!-- Point P (belongs to A, but is close to B) -->
                        <div class="point cluster-1 point-p" style="top: 50%; left: 70%;">P</div>
                        <!-- Points for Cluster B -->
                        <div class="point cluster-2" style="top: 35%; left: 80%;"></div>
                        <div class="point cluster-2" style="top: 65%; left: 85%;"></div>
                        <div class="point cluster-2" style="top: 50%; left: 90%;"></div>
                    </div>
                    <p style="font-size: 0.9em; margin-top: 10px;">Point P is closer to the neighboring cluster than its own ( `a(P)` > `b(P)` ).</p>
                </div>
            </div>

            <p style="margin-top:20px;">The average Silhouette Score across all points for a given 'k' is reported in the app, providing another way to assess clustering quality.</p>
        </div>

        <!-- Existing Clustering Process Visualization -->
        <div class="slide">
            <h2>üéØ Clustering Process Visualization</h2>
            <div class="diagram-container">
                <div>
                    <h3>Before Clustering</h3>
                    <div class="map-visual" id="beforeMap">
                        <!-- Unclustered points -->
                    </div>
                </div>
                <div style="font-size: 3em; color: #3498db;">‚Üí</div>
                <div>
                    <h3>After Clustering</h3>
                    <div class="map-visual" id="afterMap">
                        <!-- Clustered points -->
                    </div>
                </div>
            </div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color cluster-1"></div>
                    <span>Cluster 1</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color cluster-2"></div>
                    <span>Cluster 2</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color cluster-3"></div>
                    <span>Cluster 3</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2c3e50; border: 3px solid #2c3e50;"></div>
                    <span>Medoids</span>
                </div>
            </div>
        </div>

        <!-- Evaluation Metrics Slide -->
        <div class="slide">
            <h2>üìà Evaluation Metrics Overview</h2>
            <div class="metrics-container">
                <div class="metric-card">
                    <h3>Intra-cluster Distance</h3>
                    <div class="metric-value">‚Üì Lower</div>
                    <p>Sum of distances from points to their medoids. Lower values indicate tighter clusters. Used to select the optimal 'k'.</p>
                </div>
                <div class="metric-card">
                    <h3>Valid Clusters</h3>
                    <div class="metric-value">‚úì Count</div>
                    <p>Number of clusters meeting minimum size requirement for a given 'k'.</p>
                </div>
                <div class="metric-card">
                    <h3>Silhouette Score</h3>
                    <div class="metric-value">‚Üë Higher</div>
                    <p>Average quality measure (-1 to 1). Higher values indicate better-defined clusters. Provides insight.</p>
                </div>
            </div>
            
            <div class="silhouette-visual">
                <svg width="100%" height="100">
                    <defs>
                        <linearGradient id="silhouetteGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" style="stop-color:#e74c3c;stop-opacity:1" /> <!-- Poor (-1) -->
                            <stop offset="50%" style="stop-color:#f39c12;stop-opacity:1" /> <!-- Around 0 -->
                            <stop offset="100%" style="stop-color:#2ecc71;stop-opacity:1" /> <!-- Excellent (1) -->
                        </linearGradient>
                    </defs>
                    <!-- Background Gradient Bar -->
                    <rect x="0" y="20" width="100%" height="30" fill="url(#silhouetteGradient)" rx="5" ry="5"/>
                    
                    <!-- Markers and Labels -->
                    <line x1="0%" y1="15" x2="0%" y2="55" stroke="#2c3e50" stroke-width="2"/>
                    <text x="0%" y="80" text-anchor="start" fill="#333" font-weight="bold">-1 (Poor)</text>

                    <line x1="50%" y1="15" x2="50%" y2="55" stroke="#2c3e50" stroke-width="2"/>
                    <text x="50%" y="80" text-anchor="middle" fill="#333" font-weight="bold">0 (Boundary)</text>

                    <line x1="100%" y1="15" x2="100%" y2="55" stroke="#2c3e50" stroke-width="2"/>
                    <text x="100%" y="80" text-anchor="end" fill="#333" font-weight="bold">1 (Excellent)</text>
                    
                </svg>
            </div>

            <p style="text-align: center; margin-top: 10px; font-style: italic;">
                Silhouette Score Range: Poor (-1) ‚Üê ‚Üí Excellent (1)
            </p>
        </div>

        <!-- Results Slide -->
        <div class="slide">
            <div class="result-section">
                <h2 style="color: white; border-bottom: 3px solid rgba(255,255,255,0.3);">üéØ Algorithm Results Displayed</h2>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-top: 30px;">
                    <div>
                        <h3>Chosen Clusters</h3>
                        <p>The optimal set of clusters (points & their assignments) for the chosen 'k'.</p>
                    </div>
                    <div>
                        <h3>Chosen K</h3>
                        <p>The number of clusters (k) that produced the best results (lowest total intra-cluster distance).</p>
                    </div>
                    <div>
                        <h3>All Metrics Table/Charts</h3>
                        <p>Detailed evaluation data (intra-cluster distance, silhouette score, valid clusters) for all tested 'k' values.</p>
                    </div>
                    <div>
                        <h3>Warnings</h3>
                        <p>Any issues or notes encountered during processing (e.g., constraints not fully met).</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Implementation Benefits -->
        <div class="slide">
            <h2>üöÄ Why This Approach Works</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 30px; margin-top: 30px;">
                <div style="background: #f8f9fa; padding: 20px; border-radius: 15px; border-left: 5px solid #2ecc71;">
                    <h3 style="color: #2ecc71;">üåç Real-World Accuracy</h3>
                    <p>Uses actual travel times instead of straight-line distances, accounting for roads, traffic, and terrain.</p>
                </div>
                <div style="background: #f8f9fa; padding: 20px; border-radius: 15px; border-left: 5px solid #3498db;">
                    <h3 style="color: #3498db;">üéØ Robust Medoids</h3>
                    <p>K-Medoids uses actual data points as cluster centers, making it less sensitive to outliers than K-Means (which uses arithmetic means that can be skewed).</p>
                </div>
                <div style="background: #f8f9fa; padding: 20px; border-radius: 15px; border-left: 5px solid #e74c3c;">
                    <h3 style="color: #e74c3c;">üìä Multiple Metrics</h3>
                    <p>Evaluates clustering quality using intra-cluster distance (for optimization) and Silhouette Score (for insight).</p>
                </div>
                <div style="background: #f8f9fa; padding: 20px; border-radius: 15px; border-left: 5px solid #f39c12;">
                    <h3 style="color: #f39c12;">‚ö° Flexible Parameters</h3>
                    <p>Allows fine-tuning of cluster count range and minimum cluster size for different use cases.</p>
                </div>
            </div>
        </div>
    </div>

    <div class="navigation-controls">
        <button id="prev-slide" class="nav-button">‚Üê</button>
        <div id="slide-counter"></div>
        <button id="next-slide" class="nav-button">‚Üí</button>
    </div>

    <script>
        // Generate sample points for visualizations
        function generatePoints(container, clustered = false) {
            const colors = ['cluster-1', 'cluster-2', 'cluster-3', 'cluster-4', 'cluster-5'];
            const points = [
                {x: 50, y: 40, cluster: 0},
                {x: 70, y: 50, cluster: 0},
                {x: 45, y: 60, cluster: 0},
                {x: 180, y: 30, cluster: 1},
                {x: 200, y: 45, cluster: 1},
                {x: 190, y: 60, cluster: 1},
                {x: 120, y: 120, cluster: 2},
                {x: 140, y: 140, cluster: 2},
                {x: 100, y: 130, cluster: 2},
                {x: 250, y: 120, cluster: 3},
                {x: 270, y: 140, cluster: 3},
                {x: 40, y: 150, cluster: 4},
                {x: 60, y: 160, cluster: 4}
            ];

            points.forEach((point, index) => {
                const pointEl = document.createElement('div');
                pointEl.className = 'point';
                
                if (clustered) {
                    pointEl.classList.add(colors[point.cluster % colors.length]); // Use modulo for safety
                    // Make medoids (e.g. first point of each conceptual cluster group)
                    if (index === 0 || index === 3 || index === 6 || index === 9 || index === 11) {
                        pointEl.classList.add('medoid');
                    }
                } else {
                    pointEl.style.background = '#7f8c8d'; // Unclustered color
                    pointEl.classList.add('animated-point');
                }
                
                pointEl.style.left = point.x + 'px';
                pointEl.style.top = point.y + 'px';
                container.appendChild(pointEl);
            });
        }

        // Generate distance matrix
        function generateMatrix() {
            const matrixContainer = document.getElementById('distanceMatrix');
            if (!matrixContainer) return;
            matrixContainer.innerHTML = ''; // Clear previous content
            const sampleData = [
                [0, 15, 8, 25, 12],
                [15, 0, 22, 18, 30],
                [8, 22, 0, 35, 20],
                [25, 18, 35, 0, 28],
                [12, 30, 20, 28, 0]
            ];
            const numRows = sampleData.length;
            const numCols = sampleData[0].length;
            const pairColors = ['#a29bfe', '#74b9ff', '#55efc4', '#ffeaa7', '#fab1a0', '#fd79a8', '#e17055', '#00b894', '#6c5ce7', '#b2bec3'];
            const diagonalColor = '#3498db'; // A key theme color
            const colorMap = Array(numRows).fill(null).map(() => Array(numCols).fill(null));
            let colorIndex = 0;

            // Assign colors to symmetrical pairs and the diagonal
            for (let i = 0; i < numRows; i++) {
                for (let j = i; j < numCols; j++) {
                    if (i === j) {
                        colorMap[i][j] = diagonalColor;
                    } else {
                        const color = pairColors[colorIndex % pairColors.length];
                        colorMap[i][j] = color;
                        colorMap[j][i] = color;
                        colorIndex++;
                    }
                }
            }

            // Create and append cells with assigned colors
            for (let i = 0; i < numRows; i++) {
                for (let j = 0; j < numCols; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    cell.textContent = sampleData[i][j];
                    cell.style.background = colorMap[i][j];
                    if (i === j) {
                        cell.style.color = 'white';
                    }
                    matrixContainer.appendChild(cell);
                }
            }
        }

        // Generate K-Medoids visualizations
        function generateKMedoidsVisuals() {
            const initContainer = document.getElementById('kmedoids-init');
            const assignContainer = document.getElementById('kmedoids-assign');
            const updateContainer = document.getElementById('kmedoids-update');

            if (!initContainer || !assignContainer || !updateContainer) return;

            // Clear any previous content
            initContainer.innerHTML = '';
            assignContainer.innerHTML = '';
            updateContainer.innerHTML = '';

            // Shared dataset for consistency
            const dataset = [
                {x: 40, y: 50}, {x: 60, y: 30}, {x: 80, y: 60}, {x: 55, y: 80},
                {x: 150, y: 100}, {x: 180, y: 80}, {x: 160, y: 130}, {x: 190, y: 110},
                {x: 280, y: 180}, {x: 300, y: 200}, {x: 270, y: 220}, {x: 310, y: 160},
                {x: 100, y: 200}, {x: 130, y: 180}, {x: 80, y: 220},
                {x: 250, y: 40}, {x: 280, y: 60}, {x: 260, y: 80},
            ];

            const k = 3;
            const medoidColors = ['#e74c3c', '#3498db', '#2ecc71']; // Red, Blue, Green

            // --- Step 1: Initialization ---
            const initialMedoidIndices = [0, 7, 10]; // Pre-selected for a good visual
            const initialMedoids = initialMedoidIndices.map(i => dataset[i]);
            
            dataset.forEach((p, i) => {
                const pointEl = document.createElement('div');
                pointEl.className = 'point';
                pointEl.style.left = `${p.x}px`;
                pointEl.style.top = `${p.y}px`;
                
                const medoidIndex = initialMedoidIndices.indexOf(i);
                if (medoidIndex !== -1) {
                    pointEl.classList.add('medoid');
                    pointEl.style.backgroundColor = medoidColors[medoidIndex];
                } else {
                    pointEl.style.backgroundColor = '#7f8c8d'; // Grey for non-medoids
                }
                initContainer.appendChild(pointEl);
            });

            // --- Step 2: Assignment ---
            const clusters = Array.from({ length: k }, () => []);
            const svgEl = document.createElementNS("http://www.w3.org/2000/svg", "svg");

            function dist(p1, p2) {
                return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            }

            dataset.forEach(p => {
                let closestMedoidIndex = 0;
                let minDistance = Infinity;
                initialMedoids.forEach((m, medoidIdx) => {
                    const d = dist(p, m);
                    if (d < minDistance) {
                        minDistance = d;
                        closestMedoidIndex = medoidIdx;
                    }
                });
                clusters[closestMedoidIndex].push(p);

                const pointEl = document.createElement('div');
                pointEl.className = 'point';
                pointEl.style.left = `${p.x}px`;
                pointEl.style.top = `${p.y}px`;
                pointEl.style.backgroundColor = medoidColors[closestMedoidIndex];
                
                const closestMedoid = initialMedoids[closestMedoidIndex];
                if (p.x === closestMedoid.x && p.y === closestMedoid.y) {
                    pointEl.classList.add('medoid');
                }
                assignContainer.appendChild(pointEl);

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute('x1', p.x + 5);
                line.setAttribute('y1', p.y + 5);
                line.setAttribute('x2', closestMedoid.x + 7);
                line.setAttribute('y2', closestMedoid.y + 7);
                line.style.stroke = medoidColors[closestMedoidIndex];
                svgEl.appendChild(line);
            });
            assignContainer.appendChild(svgEl);

            // --- Step 3: Update ---
            const updateClusterIndex = 0; // Focus on the first cluster (red)
            const updateCluster = clusters[updateClusterIndex];
            const oldMedoid = initialMedoids[updateClusterIndex];
            
            // Find a visually better medoid for the demo
            let newMedoid = oldMedoid;
            let minTotalDist = Infinity;
            updateCluster.forEach(potentialMedoid => {
                let totalDist = 0;
                updateCluster.forEach(otherPoint => {
                    totalDist += dist(potentialMedoid, otherPoint);
                });
                if (totalDist < minTotalDist) {
                    minTotalDist = totalDist;
                    newMedoid = potentialMedoid;
                }
            });

            const updateSvgEl = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            updateCluster.forEach(p => {
                const pointEl = document.createElement('div');
                pointEl.className = 'point';
                pointEl.style.left = `${p.x}px`;
                pointEl.style.top = `${p.y}px`;
                pointEl.style.backgroundColor = medoidColors[updateClusterIndex];

                if (p.x === newMedoid.x && p.y === newMedoid.y) {
                    pointEl.classList.add('medoid', 'new-medoid');
                } else if (p.x === oldMedoid.x && p.y === oldMedoid.y) {
                    pointEl.classList.add('medoid');
                    pointEl.style.opacity = '0.5';
                }
                updateContainer.appendChild(pointEl);

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute('x1', p.x + 5);
                line.setAttribute('y1', p.y + 5);
                line.setAttribute('x2', newMedoid.x + 7);
                line.setAttribute('y2', newMedoid.y + 7);
                line.style.stroke = medoidColors[updateClusterIndex];
                updateSvgEl.appendChild(line);
            });
            updateContainer.appendChild(updateSvgEl);
        }

        // Initialize visualizations
        document.addEventListener('DOMContentLoaded', function() {
            const titleMap = document.getElementById('titleMap');
            if (titleMap) generatePoints(titleMap, true);
            
            const beforeMap = document.getElementById('beforeMap');
            if (beforeMap) generatePoints(beforeMap, false);

            const afterMap = document.getElementById('afterMap');
            if (afterMap) generatePoints(afterMap, true);
            
            generateMatrix();
            generateKMedoidsVisuals();

            // --- New Navigation Logic ---
            const slides = document.querySelectorAll('.slide');
            const slideCounter = document.getElementById('slide-counter');
            const prevButton = document.getElementById('prev-slide');
            const nextButton = document.getElementById('next-slide');
            let currentSlideIndex = 0;
            const totalSlides = slides.length;

            function showSlide(index) {
                // Hide all slides
                slides.forEach(slide => {
                    slide.classList.remove('active');
                });

                // Show the target slide
                slides[index].classList.add('active');

                // Update counter
                if (slideCounter) {
                    slideCounter.textContent = `${index + 1} / ${totalSlides}`;
                }
                
                // Update current index
                currentSlideIndex = index;
            }

            function nextSlide() {
                const newIndex = (currentSlideIndex + 1) % totalSlides;
                showSlide(newIndex);
            }

            function prevSlide() {
                const newIndex = (currentSlideIndex - 1 + totalSlides) % totalSlides;
                showSlide(newIndex);
            }

            // Event Listeners
            if (nextButton) nextButton.addEventListener('click', nextSlide);
            if (prevButton) prevButton.addEventListener('click', prevSlide);

            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowRight') nextSlide();
                else if (e.key === 'ArrowLeft') prevSlide();
            });

            // Initial setup
            if (slides.length > 0) {
                showSlide(0);
            }
        });
    </script>
</body>
</html>
